---
title: "GTseq Panel Mapping"
output:
  html_document:
    df_print: paged
    code_folding: hide
    toc: true
    toc_float: true
    toc_collapsed: false
---

```{r, message=FALSE, warning=FALSE}
#packages here
require(tidyverse)
require(DiagrammeR)
require(Biostrings)

```

# Summary
In this R notebook we map the O. mykiss GTseq panel used by the SFGL to the O. mykiss genome and examine LD patterns among the markers.

Skip to _Results Summary_ for a visual abstract of results

# Readme

This is an rstudio project. If you'd like to pre-rendered figures, read a summary of analysis and view code, please open the html file in a browser. 


To conduct the analyses on your computer, edit or run code: clone this repository into a directory on you r local machine and open the .Rproj file in Rstudio. All data and analyses are available in the github repository at https://github.com/david-dayan/Omy_GTseq_markers.git

# Metadata
__Samples__  
Samples are 42 Rogue River adult winter run steelhead collected 2019 at Cole Rivers Hatchery

__Genome__  
We use the ENSEMBL release 100 genome for mapping (GCA_002163495.1), however, we also map amplicons to a draft release of the new assembly (GCA_013265735.1).

# Analysis
## Overview

```{r}

grViz("digraph flowchart {
      # node definitions with substituted label text
      node [fontname = Helvetica, shape = rectangle]        
      tab1 [label = '@@1']
      tab2 [label = '@@2']
      tab3 [label = '@@3']
      tab4 [label = '@@4']
      tab5 [label = '@@5']
      # edge definitions with the node IDs
      tab1 -> tab3
      tab2 -> tab3
      tab3 -> tab4
      tab3 -> tab5
      }
      [1]: 'Get Amplicon Sequences'
      [2]: 'Probe+Primer Sequence'
      [3]: 'Mapping'
      [4]: 'Compare to Previous Mapping Results'
      [5]: 'LD'
      
      ")
```

The basic approach is to gather amplicon sequences for using similar filtering criteria to GTseq pipeline, then map these sequences.

Several approaches were used, final results are presented from **Approach 3**

## Chinook approach

In previous mapping project for Chinook the following approach was taken:

(1) From demultiplexed fastq files, retrieve reads with exact match to marker forward primers using grep (see code chunk below)  
(2) Generate consensus sequences across individuals (maybe just skipped to 3)  
(3) Map with bwa-mem  
(4) Filter on basis of mapping quality  

```{bash, eval=FALSE}
#!/bin/bash
seqs=(
GCCTAGGTATGTACGAAACTTCACA
CCACTGGCTGTGGAGCTT
GCAGGGAAAACTGGTCAGGA
GGTCACGATCGTGGGGTC
CGCAATGAGCCAACCCCT
TGCAGGCATCATGCTTAATAACT
CGGAAGACCAGATTCTCCAAGAGTA
TTTTCTAGGACAGGTTGCTTGCA
TGAAAGATATCAATTGTAGTAGTGGTGGTG
ACTTCTTGAGCCAATCGGATGATG
GCGACTTGACAACGAGGAGAA
CATTCCATGACAATGATTGAAATCTAAAAACAC
GCCTACTGATAAATGTATGACAGTAATGGA
CCAGCAGAGACTGGGTTCAC
TGGGACAGAGGTGGGAATTGA
CTCTGCCATTCATTTGGGCTTTG
ACCACCCACCTCCTCAGA
CAAACGCGCACTCACACACA
CAGCTGCTGCAGTCAATGAG
GCGTTACTGGTGTTATAAACGTTAGC
CCTGAGCATCCCAGTTGAACT
AGTACAAGTGCAGAGAATGACATCATG
CGATGTACTGAGGGCAGTGT
GACTGTCTTGGAACCGTTGCTA
GAACTGAGCGGCTGCTG
TGTGTACATCCGCGTAAATATTGAAGATAA
CCTCAGTGTTATTTGTATATGATCATTTTGAAACATTT
TTGTTCAATGGGCATTAATGCATGTT
CAAGGGCACATTGGCAGATTTT
ACTCTATCATCGGCAGGACCAT
ATCGAGGATGCCTCAAAGACATC
CCCACTTCCAGAGCCTGAA
GCCCTTGTGACAATGCACTGTTATA
GTGATGAGAGGTTTCCGGAAAATCT
CTCCCTTGCTTTTGGTCATTGG
CAGGCTTGTGTTAAGTAGGGAGAAA
GAGGTTTGTTACTGTCACCCATAGA
CCTTTTTCTTATTAGTTTTACTTCCCCAGAGA
TGAAATAAATTGTTCTGTTGATATGTGAATTTTGGA
GCCAGATAGTAGCGTACATCATGAG
TCTCCCTCATTCCCATGTCATATCA
AACAAAGAATGTTAAACACCAAACAGGAA
GTTTGGCTATTGAAATTATACATTAAAACATGTAGCT
CTCTTGTTTGCTATGGGAGATGTAGT
GAGTGGTCAAGGTTTCAGTTTCTG
GTATAAACTAGAGTCCAGTGTTATGTTAATGTCTT
TTGTGGAATTACACCTTCAGAGTTCAAT
CCATGCGCCTTTGAGGAAATTAA
CTGAGCTTTTTCAACTTACTTGTTGGA
CTGCATGAACGTTAACTCAAATAAAAGGT
GCATGGCTGCCCTAGAACA
GTGGGTAATCGATGCCAAAGAGAT
CATAGATGTTTATATGAAAAACCTCCCACTGT
GCCTACAGCAAATTCAGCTACACAT
GAGGCCTAATGTCTCTTGTGACT
CCCAAGTGGTGAGTGTCAGT
GGAGGTGTAGTGAAATGGGAAGAT
GTGACAGGAGACAGAAAGAGACATT
ACACCCACTTCAACCTCCATAAC
TGCAAACACAGAGGAAAGGGATTT
TCATCAAAACATGCCTCTTCTGTGT
TGCGCGTCTCATTCAACCAT
CCATACAGCCAGTCCAGGTG
ATTTTCAAACAGGCATTTATCATTGGTGAA
CAGACAGGTCACCATCACACT
GCACCGTATCAACGAGCTCAT
CTCAACAGTGCACCTCCCTTAATT
TCGCTAGGCAGAAATATAGGGTTCT
AGTTGTTCTTTTTATATTGTGTTTTTATTCCATTCCA
GGATGGTTGTCATTTCTCTGCAAA
TGGAGAACTTGCACTGAATGTGAAA
CTGCTGGCGCAGACATG
GGTTGCAGGGCAGAACTGT
TCAATGTTCATCAATGCACTTCCTGTA
CGTGTCCGGCTTCTTTTATTTCATT
CTGTTAGTGCAGAAGACGTAGCT
AACCCTATGGGAACTCGTAGAACT
TGGGACCCACATAAAGCAACTG
GCATGTAACACATTATTTGGCATATGTACT
CGGTCATTGTAAATGTCAACGGTTT
CCTATTTTTGATAGGTCATAGTGAATGGGATAG
TGATTGTCTCATGGCCAATTGTCA
GGCTCGAACCACCCAGTTTA
GGCACTCTCCCTGGCTAGA
CCGTCTGAGTAGGAGGATCAATACA
GTCTCTCTCTCTTTGCATCATTACACT
GCTCTTGCCCATCTGTAGGAT
GATCATGTCAGATAGGATGCTGAAAGT
TCTCCTGAACTAATTTAGACCTCTGAATGT
CCTGAACAAATACTTAACGCTCCAGTT
TTCCCTAATCTGACGTACTACCAACT
CTGCGTTTCTGGAATGTTTTCAGT
GCAATGGCATGACAATGGAAGTC
TGACAGATTTCACCTTTAACTAGCTAAGC
CGTGGAGTAGGTGGTTACAGTTTAT
GCCATGGAGGACTGGATGA
GCGATCAGGTGACGCTAAAATGA
TTTGTGCGTAAAGTCAGGTAGTGT
GCCCTGGAGAAGTACGTTTTAAACTAA
CCGACGCCTCACTGAGT
CCTGAACAGGTACACACAAACGA
ACTGCCACAGACACGAACTC
ACTCTGGGTCCAGGAGGTTTT
CACTTGTTCTGCACACTACTTGTC
CTGCTCACCTGCATCAGTGT 
TGTTTATCTCTGAGTGAAAAAGGTGTGT
TGCATGTTTTCTAACTGTGTTTTTGTGT
AGGTCCTCTGTCGCACCTA
GGACAATCGAAGACGAAAATATGCA
GCTGTGATTGTGCTCTAAAGACATG
CACTGAACTGTAAGCCATTGTGATT
CAACGCGGGAATGGCTTTTAA
CCGTTGCAGGACTCATCAGT
TGGGATAGAACAGGAGCTTAAACA
TGCAGGAACTTGCTATGCT
GCTGTTATAGCGCGGACTCA
TGCAGGAGGAGGAAGGCA
TGTGTATTCGTCGACCGGA
TGCCGCTGGATTTATTGACA
GCAGGGCGCAAAGTTCTT
GGCACAGCGACAGGAGTT
CCTCTGCTGAGTTTGAGGGG
GGGAGGCAGGCAAAAGGT
CTGCTTGTAGCCGTTCAGC
TGCAGGTGGGACTTAAACACA
ATCAGGTCTGGGGCGACA
GCCATATCCCGGGGCTTG
TGCAGGAGAGCAGGGTAGA
ACTGCAGGCGTCATGCTT
TGCAGGAGCTGTGATGGG
GGGAGAGGGAGACGTGGA
GGGCCACGGGGTTGTAAA
TGCAGGAGAAGCTGACTGAC
GGAGGCTCTACGTAGGCCT
CAGATGGTGCAGGCCGAA
GCAGGGGCAGACTGAAGG
CTTGCGCGGCAGTTGAAC
TGCAGGGTGGAAGAATTCATC
TGCAGGCTGACTTGGGTA
CGACCATGGCCCCCAATTCAT
CAGTTCGCTTCTCCAGGGA
TGCCTAAACACTCCCAAGGT
TGCAGGAAGAGTTCAGAGAAATCT
TGCAGGACCAACTTTCTCAT
CAAAGTGCAGGTGCTGGC
GGCGACACACACAGGGTT
GTGCCGCAACAGAGTGGA
TGACCCTCCAGCGTGACT
AAGCTATGCAGGCGACGG
CGCAAGTCAGCAGGGTGA
GCAGGGTCTGTGTGGGTT
CAGGAACCTGCTTTAATGCTCT
CTCCCTGTTCGCTAGCCG
AGATGCAGGAGGCTCTGGA
TGCAGGGTTGGGGACAATT
ACAGAGCTGTGTCTACCAGA
TGCAGGGGGACAAGAGAGA
TGCAGGGACGGGGCT
TGCCGTGAGAAACTGGTCA
CAGGCAGTCACTGAGTCCG
GCCAAGTGATCAAGTGCTTGT
ACTCTCCCAGAAGGATTCAGAGA
GCCATTTGACCAACGGAGC
GCAGGAAGCAAAGTTCGGTG
GCTGACCACCGACCACAG
ACACATGGCTCGTCTGCA
GCAGGGACAGGGCCCT
CCTGCTCTGTGTCTGGGC
AGTGCAGGTCTCCAGATTTACA
GAATGCAGGGCCAGGGAG
ATGACCAATTGAAGAGTTCTTCCGT
GGTGCCACTTTAGTATAGCTGCTTA
CCTTTGGGTCTGCTTGAGGTT
GCCCTGCCTGCAACTTC
GGTGATTTTGCCACAGAGTAGAGAT
GGACTCGTGCTTGAGGAAGATG
TCTGAACTCACCAAAGGAACACTTG
GTTCGTGGGATTGTTCAATGTTCAT
TCAAAAATGTCTATCCAACAAATACTCTGAAAAATATTG
GAGACAAAGGTTTGCAGGTTCATG
GTTCTTTTTAATGATGACTACAGGTCTTTCAC
CTTTTCTGAATTAGTGCTGTGCTTGT
GCGTACTGAGCCTGGATGACA
CAGATGAAAAATAAATAATTGGGCCATTAGGAA
CACTAAATATTCCTTATCATTTCATACTAAGTCTGAAGAA
GGTGATAACAGGTGTTGCACCAA
GGAGAACATGCATCACCATTCAAG
CAGCCCGTCCCAAAATCAAG
CACAGGAAGGACGTGTTTTGATG
CAAGAACACCGAGATCTCCTTCA
TGCTTCAGTGAAAATAAGCGTGAGA
TCTTTGATATTGAGCTCATAAAAGCAAGGT
TGCATCCATTCATACCTGACCAATT
TTGAGAACATGTGGTAATTAACTACAATGACTAA
TAGGAGTTGGAAAGACTGCACA
ACAGTATACCGGCTGCCTATTCATA
CACCTTAGTTCCACGCAACATG
GGTAGGCCGTCAGTGTAAAATAAGT
GAGGCTGACTTGGACTTTGC
CCTCCAGATGAGACCCACTCT
CGTGGTGTTCGCCTTCCT
GACTCAGGTAAGGAAACATCAATGTCA
CACCTGAACCTCCACTGTGT
CAATTACTCTTTCTCAGCCCTGTGT
CGTGACCCTTGTAACTGAAAAGC
TGTTGTCTCGGACTGCATGAC
GATCATTTATCAAGACTATAGGCTATGGATACG
GTCCACATTCTCCAGTACATGTATGG
GTCCTCAGCTGGGTCAAGAG
CAAGGGATGTGACAAATTAATCAAACACATAA
CCTTAGCTGCTCTTTGAAGTTGACT
CTCCCCCCTGGACTTTGG
GTGTGTGTGTGTGTGTGTCATCGT
TGCCACCTCAGTTTTAGTGTTATATCC
CTCACTGCAAATCCAACTTCATCAT
CCGTCCACAGCACAAGACTATAATA
CATTTAGCAGACACTCTTATCTTAGTGTCA
GTGCTGCAGGAACCATGTG
GGCCATCTTTCAGGACGTACAG
TGCAGTTACAAGCCTAAGACAATCT
CCAGCCCCGTAACACACAT
CGCTGGGCATGGATGAGT
GGTCTGTCTGTCTGTCTATCTGTCAATG
AAATGAGGCCGTCCTTTACACT
GCCGAAAAATAAGCGATTAGTGATGA
CGGACAAAGAGCTACAGAAATGC
ATGTCAATATATTTCACTATAATGATTGGAAGCCA
TGAGCGAGATTTATCAAACTGTCAAAGA
GGAACTTCCTCTCCCGTTCTG
AGTCAGTGTTGGTGTAGTGAAGAGA
AGAGCATTCAATTTAAAAGCTGAAAACGA
CTCATACTTTGTACCTGTGTGTTCCA
GCATTACTAAAAACTGGTGTGTGGAA
CTCTTGCTACTTGCAGTGTATCTCA
TGTTTTTGGTCATGTATTTTCTCTGCTATTTTT
CCTGGTCTGTTTGTGATCAAGATG
TCTTTGGACTGTGTATACCAGGTGTA
CATTTCCACGAAAAGCCAGATGAC
TCATAAACATGGTGTCTTTCAGTCAGTT
TTCTGGGTTGCCATACTCTTTCAAT
AAGGTCTACTCCGGTTGTATTCGGT
TGCCATCATAAACAACCTAACAAGTAACT
CCAAATACAGACCAGCTACTTGTGT
GTCGATTACCGTTAGCTTCATCCT
CTAAGTTCTTCCTGCCTAATGTGGAT
AATATTGGCTTTCTGAGAATGCATTTGG
CCATTCCCATCGGCATCGT
TGTGTTTAGGATTGAACTGACCATGTT
TCAAAGACATCGAACACAAGAACGA
TTTCTCATCCTTCTCTCTTCCAGTCT
ACCAGTACCTAAACGTTAGAAAGCAA
GCCTCACATTTTACTGATGTCACTTC
TTTTAAAAATGGAGATAAACTCCTGACCTGAA
TGCACCTGCGAGAGCAT
CCAAATCCTCATCCCACACACT
GCCAATACGGGTTCTGAACTGT
TGTTGTAATCTTTCTGAATATTTGCTTGCTT
GGACAAGTTGAAACAGATCAGGAAGT
CCTTCAAACTAACACATCATAGACATGCTT
GTCAACAAATGCAGGTAACATAAATGGT
CTCGCCTCTGTCATTGTATTACCTT
TTGCCCATTCACCATCGGAAT
GGAAACCAGCTAGGATTCAGGAA
GGATGTAGAGTGAAATCACCTTCGA
CGCGAGTTAGCTCGAATATTATGATTTC
AGACAATCATGGTGTTTTGAGTCTTTCT
GCTGAGGAAGGATTCTGTATTTGCT
AGCTAGGCTGTAAATGCAAGGAT
GGTTTGAGCCAATCAGTTGTGTT
GAGGATGACACTGTCCGTTTGT
CCGCCTTTCCCACCTTCTC
GGGACCACATAGAAAACATCTGTCT
GGCAGGTAAGTGGAACGTTTTAGAT
CGAAATAAGGGCCTGGTGTTTAAAA
GGATGACTCCTACTAATAGACGGATGT
CACTTTTGACTTTACATGGAACTTAACTCAT
TGGTGAGAGCAGCTTTAAATGTCTT
CCCCATATGAGACGCTACAGTAATG
CCAGGTCGTCTTTATTGCAGATTATCA
TCGTGGATTGTGGCTTACGT
AATGGGTAACAAAGAAATAGCTAGCTACTT
CTGGTCTGTGACGTCAAAATGATG
CATAGTATAGTGATTCGAGTCTGGAGTCT
ATCCAAGGAGCCCCATTAAAGATTT
CAATGTCTAAAGTAATGGTGGTATTCTTGC
CCAGAGGTTAGATGGCCCTTT
GAAAAAGTAAAGTAAAAGTAAAGTATTATACCACTAAAGACAAT
TAACCATGACTTCTATCAATCACCCC
GAAACGTCTATGCTGTCCCCTTTAA
TTTGAGTGAGTCACTGCACCAA
TCAAGACTGTGCTGTAGTTGTCTAC
ATGGGTTGGGATTATGGTTCATTGT
CAAATCAGAACAAAACCTCCCACAA
GGGCAATGGTGGCTATGCT
CTTTTCGGGTTATTCATGCTGTTGT
CTACGCGAGAAATAACACTTTTCAAAACT
TGCTGAGGACCATCTGCAATTC
GCCTACCAGAAAGTACCAATTGTGA
CGGTTCGTGTCCATTGCATTATTAT
CTCATCTCATTATCTACCTTAACGTGCA
)
loci=(
Ots_110495-380
Ots_ARNT
Ots_crRAD18289-33
Ots_crRAD48459-74
Ots_crRAD55400-59
Ots_crRAD57376-68
Ots_100884-287
Ots_101119-381
Ots_101554-407
Ots_101704-143
Ots_101770-82
Ots_102213-210
Ots_102414-395
Ots_102457-132
Ots_102801-308
Ots_102867-609
Ots_103041-52
Ots_103122-180
Ots_104048-194
Ots_104063-132
Ots_104415-88
Ots_105105-613
Ots_105132-200
Ots_105385-421
Ots_105401-325
Ots_105407-117
Ots_105897-124
Ots_106313-729
Ots_106419b-618
Ots_106499-70
Ots_106747-239
Ots_107074-284
Ots_107285-93
Ots_107607-315
Ots_107806-821
Ots_108007-208
Ots_108390-329
Ots_108735-302
Ots_108820-336
Ots_109525-816
Ots_109693-392
Ots_110064-383
Ots_110201-363
Ots_110381-164
Ots_110551-64
Ots_110689-218
Ots_111084b-619
Ots_111312-435
Ots_111681-657
Ots_112208-722
Ots_112301-43
Ots_112419-131
Ots_112820-284
Ots_112876-371
Ots_113242-216
Ots_113457-40R
Ots_115987-325
Ots_117242-136
Ots_117259-271
Ots_117370-471
Ots_117432-409
Ots_118175-479
Ots_118205-61
Ots_118938-325
Ots_120950-417
Ots_122414-56
Ots_123048-521
Ots_123921-111
Ots_124774-477
Ots_126619-400
Ots_127236-62
Ots_127760-569
Ots_128302-57
Ots_128693-461
Ots_128757-61R
Ots_129144-472
Ots_129170-683
Ots_129458-451
Ots_129870-55
Ots_130720-99
Ots_131460-584
Ots_131802-393
Ots_131906-141
Ots_94857-232R
Ots_94903-99R
Ots_95442b-204
Ots_96222-525
Ots_96500-180
Ots_96899-357R
Ots_97077-179R
Ots_97660-56
Ots_98409-850
Ots_98683-796
Ots_99550-204
Ots_afmid-196
Ots_AldB1-122
Ots_aldb-177M
Ots_AldoB4-183
Ots_arp-436
Ots_AsnRS-60
Ots_aspat-196
Ots_BMP2-SNP1
Ots_brp16-64
Ots_Cath_D141
Ots_CCR7
Ots_CD59-2
Ots_CD63
Ots_cgo24-22
Ots_Chin30up-211
Ots_CirpA
Ots_cox1-241
Ots_CRB211
Ots_crRAD10447-25
Ots_crRAD11620-55
Ots_crRAD12037-39
Ots_crRAD12711-37
Ots_crRAD13725-51
Ots_crRAD16540-50
Ots_crRAD17527-58
Ots_crRAD18492-65
Ots_crRAD18937-60
Ots_crRAD20262-46
Ots_crRAD20376-66
Ots_crRAD20887-70
Ots_crRAD21115-24
Ots_crRAD22960-32
Ots_crRAD23631-48
Ots_crRAD24807-74
Ots_crRAD25367-50
Ots_crRAD255-59
Ots_crRAD26081-28
Ots_crRAD26165-69
Ots_crRAD26541-47
Ots_crRAD27164-55
Ots_crRAD27515-69
Ots_crRAD2806-42
Ots_crRAD28677-65
Ots_crRAD292-21
Ots_crRAD30341-48
Ots_crRAD33054-62
Ots_crRAD33491-71
Ots_crRAD34397-33
Ots_crRAD35313-66
Ots_crRAD36072-29
Ots_crRAD36152-44
Ots_crRAD3758-51
Ots_crRAD38095-29
Ots_crRAD38746-36
Ots_crRAD42058-48
Ots_crRAD44588-67
Ots_crRAD46081-56
Ots_crRAD46751-42
Ots_crRAD47297-55
Ots_crRAD5061-27
Ots_crRAD55475-26
Ots_crRAD57520-66
Ots_crRAD57537-24
Ots_crRAD57687-34
Ots_crRAD60614-46
Ots_crRAD60620-51
Ots_crRAD61523-71
Ots_crRAD66330-60
Ots_crRAD69327-53
Ots_crRAD73823-60
Ots_crRAD74766-28
Ots_crRAD75581-70
Ots_crRAD76512-28
Ots_crRAD78968-46
Ots_crRAD92420-25
Ots_crRAD9615-69
Ots_DDX5-171
Ots_E2-275
Ots_EndoRB1-486
Ots_EP-529
Ots_Est1363
Ots_Est740
Ots_ETIF1A
Ots_FARSLA-220
Ots_FGF6A
Ots_FGF6B_1
Ots_GCSH
Ots_GDH-81x
Ots_GH2
Ots_GnRH-271
Ots_GPDH-338
Ots_GPH-318
Ots_GST-207
Ots_GST-375
Ots_GTH2B-550
Ots_HFABP-34
Ots_HMGB1-73
Ots_hnRNPL-533
Ots_hsc71-3-488
Ots_hsc71-5-453
Ots_hsp27b-150
Ots_Hsp90a
Ots_HSP90B-100
Ots_IGF-I.1-76
Ots_Ikaros-250
Ots_IL11
Ots_IL8R_C8
Ots_IsoT
Ots_LEI-292
Ots_LWSop-638
Ots_mapK-3-309
Ots_mapKpr-151
Ots_MetA
Ots_MHC1
Ots_MHC2
Ots_mybp-85
Ots_Myc-366
Ots_myo1a-384
Ots_myoD-364
Ots_NAML12-SNP1
Ots_nelfd-163
Ots_NFYB-147
Ots_nkef-192
Ots_NOD1
Ots_nramp-321
Ots_ntl-255
Ots_Ostm1
Ots_OTALDBINT1-SNP1
Ots_OTDESMIN19-SNP1
Ots_Ots311-101x
Ots_OTSMTA-SNP1
Ots_OTSTF1-SNP1
Ots_P450-288
Ots_P450
Ots_P53
Ots_parp3-286
Ots_PEMT
Ots_PGK-54
Ots_pigh-105
Ots_pop5-96
Ots_ppie-245
Ots_Prl2
Ots_RAD4543-52
Ots_RAG3
Ots_RAS1
Ots_redd1-187
Ots_RFC2-558
Ots_S7-1
Ots_SClkF2R2-135
Ots_sept9-78
Ots_SERPC1-209
Ots_SL
Ots_slc7a2-71
Ots_stk6-516
Ots_SWS1op-182
Ots_TAPBP
Ots_TCTA-58
Ots_TGFB
Ots_Thio
Ots_TLR3
Ots_TNF
Ots_Tnsf
Ots_tpx2-125
Ots_trnau1ap-86
Ots_txnip-321
Ots_u07-07.161
Ots_u07-17.135
Ots_u07-17.373
Ots_u07-18.378
Ots_u07-19.260
Ots_u07-20.332
Ots_u07-25.325
Ots_u07-49.290
Ots_u07-53.133
Ots_u07-57.120
Ots_u07-64.221
Ots_u1002-75
Ots_u1004-117
Ots_u1006-171
Ots_u1007-124
Ots_u1008-108
Ots_u202-161
Ots_u211-85
Ots_U212-158
Ots_U2305-63
Ots_U2362-227
Ots_U2362-330
Ots_U2446-123
Ots_U2567-104
Ots_u4-92
Ots_U5049-250
Ots_U5121-34
Ots_u6-75
Ots_unk1104-38
Ots_unk1832-39
Ots_unk3513-49
Ots_unk526
Ots_unk7936-50
Ots_unk9480-51
Ots_USMG5-67
Ots_vatf-251
Ots_zn593-346
Ots_zP3b-215
Ots_ZR-575
Ots_Greb1_snp1
Ots_Greb1_snp2
)


for j in {1..300}; do
	for i in $( grep -n "${seqs[$j]}" /nfs1/FW_HMSC/OMalley_Lab/bohns/GTseq/RogueR/CORH/sample_fastqs/PT01_A01_CRH01_OtsAC18CORH_0101.fastq | cut -d : -f 1 ); do
	sed -n "$((i-1))","$((i+2))"'p ; '"$((i+3))"q /nfs1/FW_HMSC/OMalley_Lab/bohns/GTseq/RogueR/CORH/sample_fastqs/PT01_A01_CRH01_OtsAC18CORH_0101.fastq >> OtsGTseqLD/"${loci[$j]}".fq
	done
done

```

However, Sandra described this approach as time-consuming (mostly due to sorting off target reads that contained the primer, but not the probe), so it may be good to try an alternative approach before doing this.

## Approach 2

In this approach we modify the GTseq pipeline scripts to pull out "on target reads" identified by the pipeline and then just keep a set of these for each individual.

The GTseq_SeqTest.pl script from the GTseq pipeline is able to read in a list of all unique reads (from GTseq_HashSeqs.pl), and count the occurences of the forward and probe sequences. Below, we modify the script so that it also outputs the sequences that match. After a file of matching sequences is created, we create a consensus sequence for each marker, and then use this for mapping. 

```{bash, eval = FALSE}
#!/usr/bin/perl
#GTseq_SeqTest.pl by Nate Campbell, modified by David Dayan to collect matching reads from the input hash file
## comments with double hashes (##) throughout are Dayan's interpretation of the script and may be wrong
#Test .hash file to see how many times loci fwd primers and probe seqs occur.

use strict; use warnings;

die "usage: provide <tab delimited txt file of locus, fwd, probe1, probe2 seqs> and <*.hash>\n" unless @ARGV == 2;

##initialize variables/arrays
my @assays = ();
my @fwd_seq = ();
my @probe1 = ();
my @probe2 = ();
my @probe1RC = ();
my @probe2RC = ();

my @fwd_count = ();
my @probe_count = ();
my @both_count = ();

my @sequences = (); ## initialize new array for the reads

#read in assay and allele information and push to arrays...

open(SEQ, "<$ARGV[0]") or die "error reading $ARGV[0]\n";
## open the key file and write the assay (sequence name), fwd primer, and probe sequences to arrays, also write reverse complements of probe sequences
while (<SEQ>) {
	chomp;
	my @info = split(/\t/, $_);
	push @assays, $info[0];
	push @fwd_seq, $info[1];
	push @probe1, $info[2];
	push @probe2, $info[3];
	my $p1RC = reverse $info[2];
	my $p2RC = reverse $info[3];
	$p1RC =~ tr/ACGT/TGCA/;
	$p1RC =~ tr/\]\[/\[\]/;
	$p2RC =~ tr/ACGT/TGCA/;
	$p2RC =~ tr/\]\[/\[\]/;
	push @probe1RC, $p1RC;
	push @probe2RC, $p2RC;
		}
close SEQ;

my $Targets = @assays; ##creates a variable for each marker

for (my $i = 0; $i < $Targets; $i++){
$fwd_count[$i] = 0;
$probe_count[$i] = 0;
$both_count[$i] = 0;
$sequences[$i] = 0 ; ## add variable to keep sequences within the $Targets variable

open(HASH, "<$ARGV[1]") or die "error reading $ARGV[1]\n";

	while (<HASH>) {
		my $hash = $_;
		my $R1_seq = <HASH>;
		chomp ($hash);
		my @info = split(/;/, $hash);
		my $count = $info[2];

			if ($R1_seq =~ m/$fwd_seq[$i]/){
			$count = $fwd_count[$i] + $count;
			$fwd_count[$i] = $count;
			}
			$count = $info[2];
			if ($R1_seq =~ m/$probe1[$i]|$probe2[$i]|$probe1RC[$i]|$probe2RC[$i]/){
			$count = $probe_count[$i] + $count;
			$probe_count[$i] = $count;
			}
			$count = $info[2];
			if (($R1_seq =~ m/$fwd_seq[$i]/) && ($R1_seq =~ m/$probe1[$i]|$probe2[$i]|$probe1RC[$i]|$probe2RC[$i]/)) {
			$count = $both_count[$i] + $count;
			$both_count[$i] = $count;
			$sequences[$i] = $R1_seq; ##add sequence 
			}
		}
	}
close HASH;

# print "$Allele1_Count[0]\n"; #testing...

for (my $j = 0; $j < $Targets; $j++){
	print "$assays[$j],$fwd_count[$j],$probe_count[$j],$both_count[$j],$sequences[$j]\n"; ##added sequence to variable
	}
```

Now run the hash script on an demuxed fastq file, then run the modified script on the hash output
```{bash, eval=FALSE}
SGE_Batch -c "perl ./scripts/hashseqs.pl ./demuxed_fastq/PT25_C06_ROGR_OmyAC19APPR_0220.fastq > APPR220.hash" -r log_hash

#next create the input file for the gtseq panel
# used the file at /dfs/FW_HMSC/Omalley_Lab/bohns/GTseq/Omy_GTseq390_ProbeSeqs.csv, needed to edit it to be in the right format (locus, fwd, probe1, probe2) (Locus Name,Allele1,Allele2,ProbeSeq1,ProbeSeq2,FWD_Primer,A1_correction,A2_correction)

awk 'BEGIN{FS=",";OFS="\t"} {print $1,$6,$4,$5}' /dfs/FW_HMSC/Omalley_Lab/bohns/GTseq/Omy_GTseq390_ProbeSeqs.csv  > probe_seqs.csv

SGE_Batch -c "perl ./scripts/gtseq_seqtest_modified.pl probe_seqs.csv APPR220.hash > seqs.txt" -r log_seqtest

#clean up error in the output 
sed -i ':a;N;/\n;/s/\n//;ta;P;D' seqs.txt
sed -i '/^$/d' seqs.txt

#stopped here
#generated a file of unique reads for each marker than could be collapsed into a consensus sequence and mapped however there are some issues with this approach (see approach 3)
```

## Approach 3 (used this one)

This approach maps achieves several goals:  

(1) Map reads from many individuals to increase diversity  
(2) Assess probability of paralogous markers  
(3) Work only on reads that will enter the GTseq pipeline (i.e. conduct read filtering the same way as GTseq pipeline)  
(4) If amplicons are not paralagous, generate a final consensus sequence for future mapping projects on new genome when it is published.   

In approaches 1 and 2 above, generating a consensus sequence for the amplicon before mapping will obfiscate any paralogous sequences that will be pulled by the gtseq pipeline, because reads from paralagous loci will be collapsed into a single marker's estimated amplicon sequence. By aligning the full reads against the genome, we can check if any markers are multi-mapping before building and mapping consensus sequence.

```{r}

grViz("digraph flowchart {
      # node definitions with substituted label text
      node [fontname = Helvetica, shape = rectangle]        
      tab1 [label = '@@1']
      tab2 [label = '@@2']
      tab3 [label = '@@3']
      tab4 [label = '@@4']
      tab5 [label = '@@5']
      tab6 [label = '@@6']
      tab7 [label = '@@7']
      tab8 [label = '@@8']
      # edge definitions with the node IDs
      tab1 -> tab2 [label = 'concat']
      tab2 -> tab3 [label = 'split into marker-level files by primer+probe sequence']
      tab3 -> tab4 [label = 'align (bwa-mem)']
      tab4 -> tab5 [label = 'merge bams']
      tab5 -> tab6 [label = 'samtools: mpileup + consensus']
      tab5 -> tab7
      tab4 -> tab8 [label = 'marker level mapQ and genome positions']
      }
      [1]: 'demuxed fastq'
      [2]: 'merged fastq'
      [3]: 'marker-level fastqs'
      [4]: 'marker-level bams'
      [5]: 'merged bams'
      [6]: 'amplicon consensus sequence'
      [7]: 'vcf file'
      [8]: 'mapping statistics/paralog ID'



      
      ")
```

### Mapping

First step is to generate by-marker fastq files from al samples in the dataset
```{bash, eval = FALSE}
#first step is to concatenate some fish from a single population in to a large fastq
# will use the Rogue adult winter fish (CORH and APPR adults at /dfs/FW_HMSC/Omalley_Lab/bohns/GTseq/OmyRogue/baseline/sample_fastqs/)

#from the fastqs directory
touch merged.fq
cat /dfs/FW_HMSC/Omalley_Lab/bohns/GTseq/OmyRogue/baseline/sample_fastqs/*CORH* >> merged.fq
cat /dfs/FW_HMSC/Omalley_Lab/bohns/GTseq/OmyRogue/baseline/sample_fastqs/*APPR* >> merged.fq

```


```{r, message=FALSE, warning=FALSE}
# get panel marker information
panel <- read_tsv("GTseq_panel_metadata/probe_seqs.csv", col_names = c("marker", "primer","probe1", "probe2"))

#reverse complement function
reverse_chars <- function(string)
{
  # split string by characters
  string_split = strsplit(string, split = "")
  # reverse order
  rev_order = nchar(string):1
  # reversed characters
  reversed_chars = string_split[[1]][rev_order]
  # collapse reversed characters
  paste(reversed_chars, collapse = "")
} 


panel$probe1rc <- chartr("ATGC","TACG",reverse_chars(panel$probe1))
panel$probe2rc <- chartr("ATGC","TACG",reverse_chars(panel$probe2))

panel2 <- panel %>%
  unite(probes, c(probe1, probe1rc, probe2, probe2rc), sep = "|" )

panel2$primer <- paste("^", panel2$primer, sep="")
write_tsv(panel2, "./GTseq_panel_metadata/gtseq_panel.txt", col_names = FALSE)

```

```{bash, eval = FALSE}
#next we'll filter the merged fastq into files for each marker based on the presence of the primer and probe sequence using seqkit for speed 
#can also consider using bbduk and kmer matching to speed up if this is too slow

#set an SGE array with a task dedicated to each line of the probes_seqs.csv file

#!/bin/bash
#$ -S /bin/bash

#$ -t 1-10

#$ -tc 2

#$ -N marker_split

#$ -cwd

#$ -o $JOB_NAME_$TASK_ID.out

#$ -e $JOB_NAME_$TASK_ID.err


SEQKIT="/dfs/FW_HMSC/Omalley_Lab/dayan/software/seqkit"
MARKER_NAME=$(awk -v "line=$SGE_TASK_ID" 'NR == line {print $1}' ../gtseq_panel.txt)
PRIMER=$(awk -v "line=$SGE_TASK_ID" 'NR == line {print $2}' ../gtseq_panel.txt)
PROBE=$(awk -v "line=$SGE_TASK_ID" 'NR == line {print $3}' ../gtseq_panel.txt)


cat merged.fq | $SEQKIT grep -s -i -r -p $PRIMER | $SEQKIT grep -s -i -r -p $PROBE > $MARKER_NAME.fq 


```

Then we align to the genome with bwa-mem
```{bash, eval=FALSE}
#next step is to align to the genome

#first create bwa index
SGE_Batch -c "bwa index Oncorhynchus_mykiss.Omyk_1.0.dna.toplevel.fa.gz" -r bwa_index

# then align each of the 390 files in the fastq directory using the script below and call with:
# qsub -q harold -c "scriptname"

#!/bin/bash
#$ -S /bin/bash

#$ -t 1-390

#$ -tc 10

#$ -N align

#$ -cwd

#Get demuxed files
FILES=($(ls -1 ../fastqs/fq))

#set up the loop
FILENAME=${FILES[$SGE_TASK_ID-1]}
GENOME="/dfs/FW_HMSC/Omalley_Lab/dayan/genomes/Omykiss/Oncorhynchus_mykiss.Omyk_1.0.dna.toplevel.fa.gz"

bwa mem $GENOME $FILENAME | samtools view -bSu - | samtools sort - -o ./${FILENAME%.fq}.bam &> bwa_mem.oe


```

### Marker Mapping Stats
Next we analyze mapping statistics for each marker

### Consensus Sequence
Here we generate a Rogue River marker consensus sequence that can be used for future mapping projects. 


## Probe + Primer

The chinook results suggests that there are significant enough number of off target reads that coatin the forward primer that this is not enoguh information to map on. However, adding the probe sequence and the reverse primer may be enough to permit accurate mapping and has the advantage of not having to deal with raw reads. The challenge here will be (a) correctly orienting the primer, probe and reverse primer into a concatenated sequence to map, and (b) optimizing mapping to deal with a gapped alignment (i.e. will be missing some sequence that is not included in the primers or the probe, but do not know exactly how much)

Also of note here is that the GTseq pipeline does not use alignment match reads to primer/probe sequences, instead it simply pulls a a read at a time and checks that it contains an exact match to the forward primer AND either one of the probe sequences or its reverse complement, so making a set of rules for an aligner that is similar should be relatively straightforward.


# Results Summary

summary
